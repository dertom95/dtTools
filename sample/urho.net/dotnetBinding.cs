/*block:main|file:custom.cs*/
// WARNING - AUTOGENERATED - DO NOT EDIT
// 
// Animatable.cs
// 
using System;
using System.Runtime.InteropServices;
using System.Collections.Generic;
using Urho.Urho2D;
using Urho.Gui;
using Urho.Resources;
using Urho.IO;
using Urho.Navigation;
using Urho.Network;

namespace Urho
{
/*block:class*/	
    /// <summary>
	/// Base class for animatable object, an animatable object can be set animation on it's attributes, or can be set an object animation to it.
	/// </summary>
	public unsafe partial class /*name:name*/Animatable/*endname*/ : /*name:supertype|auto*/Serializable/*endname*/
	{
		unsafe partial void /*name:name|pre:On|post:Created*/OnAnimatableCreated/*endname*/ ();

		[Preserve]
		public /*name:name*/Animatable/*endname*/ (IntPtr handle) : base (handle)
		{
			/*name:name|pre:On|post:Created*/OnAnimatableCreated/*endname*/ ();
		}

		[Preserve]
		protected /*name:name*/Animatable/*endname*/ (UrhoObjectFlag emptyFlag) : base (emptyFlag)
		{
			/*name:name|pre:On|post:Created*/OnAnimatableCreated/*endname*/ ();
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern int /*name:name|post:_GetType*/Animatable_GetType/*endname*/ (IntPtr handle);

		private StringHash UrhoGetType ()
		{
			Runtime.ValidateRefCounted (this);
			return new StringHash (/*name:name|post:_GetType*/Animatable_GetType/*endname*/ (handle));
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr /*name:name|post:_GetType*/Animatable_GetTypeName/*endname*/ (IntPtr handle);

		private string GetTypeName ()
		{
			Runtime.ValidateRefCounted (this);
			return Marshal.PtrToStringAnsi (/*name:name|post:_GetType*/Animatable_GetTypeName/*endname*/ (handle));
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern int /*name:name|post:_GetType*/Animatable_GetTypeStatic/*endname*/ ();

		private static StringHash GetTypeStatic ()
		{
			Runtime.Validate (typeof(/*name:name*/Animatable/*endname*/));
			return new StringHash (/*name:name|post:_GetType*/Animatable_GetTypeStatic/*endname*/ ());
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern IntPtr /*name:name|post:_GetType*/Animatable_GetTypeNameStatic/*endname*/ ();

		private static string /*name:name|post:_GetType*/Animatable_GetTypeNameStatic/*endname*/ ()
		{
			Runtime.Validate (typeof(/*name:name*/Animatable/*endname*/));
			return Marshal.PtrToStringAnsi (/*name:name|post:_GetType*/Animatable_GetTypeNameStatic/*endname*/ ());
		}

		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern void /*name:name|post:_RegisterObject*/Animatable_RegisterObject/*endname*/ (IntPtr context);

		/// <summary>
		/// Register object factory.
		/// 
		/// </summary>
		public static void /*name:name|post:_RegisterObject*/Animatable_RegisterObject/*endname*/ (Context context)
		{
			Runtime.Validate (typeof(/*name:name*/Animatable/*endname*/));
			/*name:name|post:_RegisterObject*/Animatable_RegisterObject/*endname*/ ((object)context == null ? IntPtr.Zero : context.Handle);
		}

/*block:method*/
		[DllImport (Consts.NativeImport, CallingConvention = CallingConvention.Cdecl)]
		internal static extern /*name:returnType|required|enum:CStype*/bool/*endname*/ /*name:name|echo:%s_%s,@class.name,@*/Animatable_LoadXML/*endname*/ (IntPtr handle/*block:params*/ /*name:type|enum,CStype|required|pre:,*/,IntPtr/*endname*/ /*name:name*/source/*endname*/ /*endblock:params*/);

		/// <summary>
		/// Load from XML data. Return true if successful.
		/// </summary>
		public override /*name:returnType|required|enum:CStype*/bool/*endname*/ /*name:name*/LoadXML/*endname*/ (XmlElement source)
		{
			Runtime.ValidateRefCounted (this);
			return /*name:name|echo:%s_%s,@class.name,@*/Animatable_LoadXML/*endname*/ (handle, (object)source == null ? IntPtr.Zero : source.Handle);
		}
/*endblock:method*/

/*block:rip*/
/*name:type|enum:int,CStype*/int/*endname*/ intValue=0;
/*name:type|enum:float,CStype*/float/*endname*/ floatValue=0.5f;
/*name:type|enum:bool,CStype*/bool/*endname*/ boolValue=true;
/*name:type|enum:string,CStype*/string /*endname*/ stringValue="";
/*name:type|enum:short,CStype*/short/*endname*/ shortValue=1;
/*name:type|enum:void,CStype*/void/*endname*/* voidValue;
/*name:type|enum:uint,CStype*/uint/*endname*/ uintValue;
/*name:type|enum:s_char_ptr,CStype*/IntPtr/*endname*/ s_charPtrValue;
/*name:type|enum:vec3,CStype*/Vector3/*endname*/ vec3;
/*name:type|enum:c_vec3,CStype*/Vector3/*endname*/ vec3;

/*endblock:rip*/
    }

/*endblock:class*/    
}
/*endblock:main*/